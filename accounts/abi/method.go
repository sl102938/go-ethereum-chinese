// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package abi

import (
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/crypto"
)

// FunctionType represents different types of functions a contract might have.
// FunctionType 表示合约可能具有的不同类型的功能。
type FunctionType int

const (
	// Constructor represents the constructor of the contract. The constructor function is called while deploying a contract.
	// Constructor代表合约的构造者。部署合约时会调用构造函数。
	Constructor FunctionType = iota
	// Fallback represents the fallback function. This function is executed if no other function matches the given function signature and no receive function is specified.
	// Fallback代表后备功能。如果没有其他函数与给定函数签名匹配并且未指定接收函数，则执行此函数。
	Fallback
	// Receive represents the receive function. This function is executed on plain Ether transfers.
	// Receive代表接收函数。该函数在普通以太传输上执行。
	Receive
	// Function represents a normal function.
	// Function 代表一个正常的函数。
	Function
)

// Method represents a callable given a `Name` and whether the method is a constant. If the method is `Const` no transaction needs to be created for this particular Method call. It can easily be simulated using a local VM. For example a `Balance()` method only needs to retrieve something from the storage and therefore requires no Tx to be sent to the network. A method such as `Transact` does require a Tx and thus will be flagged `false`. Input specifies the required input parameters for this gives method.
// 方法表示给定“名称”的可调用对象以及该方法是否为常量。如果该方法是“Const”，则无需为此特定方法调用创建事务。可以使用本地虚拟机轻松模拟它。例如，“Balance()”方法只需要从存储中检索某些内容，因此不需要将 Tx 发送到网络。诸如“Transact”之类的方法确实需要 Tx，因此将被标记为“false”。输入指定此给出方法所需的输入参数。
type Method struct {
	// Name is the method name used for internal representation. It's derived from the raw name and a suffix will be added in the case of a function overload.
	// 名称是用于内部表示的方法名称。它源自原始名称，并且在函数重载的情况下将添加后缀。
	// e.g. These are two functions that have the same name: * foo(int,int) * foo(uint,uint) The method name of the first one will be resolved as foo while the second one will be resolved as foo0.
	// 例如这是两个具有相同名称的函数： * foo(int,int) * foo(uint,uint) 第一个函数的方法名称将被解析为 foo，而第二个函数将被解析为 foo0。
	Name    string
	RawName string // RawName is the raw method name parsed from ABI // RawName 是从 ABI 解析的原始方法名称

	// Type indicates whether the method is a special fallback introduced in solidity v0.6.0
	// Type 指示该方法是否是 Solidity v0.6.0 中引入的特殊后备方法
	Type FunctionType

	// StateMutability indicates the mutability state of method, the default value is nonpayable. It can be empty if the abi is generated by legacy compiler.
	// StateMutability表示方法的可变状态，默认值为nonpayable。如果 abi 是由旧版编译器生成的，则它可以为空。
	StateMutability string

	// Legacy indicators generated by compiler before v0.6.0
	// v0.6.0 之前的编译器生成的旧指标
	Constant bool
	Payable  bool

	Inputs  Arguments
	Outputs Arguments
	str     string
	// Sig returns the methods string signature according to the ABI spec. e.g.		function foo(uint32 a, int b) = "foo(uint32,int256)" Please note that "int" is substitute for its canonical representation "int256"
	// Sig 根据 ABI 规范返回方法字符串签名。例如function foo(uint32 a, int b) = "foo(uint32,int256)" 请注意，“int”替代了其规范表示“int256”
	Sig string
	// ID returns the canonical representation of the method's signature used by the abi definition to identify method names and types.
	// ID 返回 abi 定义用来标识方法名称和类型的方法签名的规范表示。
	ID []byte
}

// NewMethod creates a new Method. A method should always be created using NewMethod. It also precomputes the sig representation and the string representation of the method.
// NewMethod 创建一个新方法。应始终使用 NewMethod 创建方法。它还预先计算方法的 sig 表​​示形式和字符串表示形式。
func NewMethod(name string, rawName string, funType FunctionType, mutability string, isConst, isPayable bool, inputs Arguments, outputs Arguments) Method {
	var (
		types       = make([]string, len(inputs))
		inputNames  = make([]string, len(inputs))
		outputNames = make([]string, len(outputs))
	)
	for i, input := range inputs {
		inputNames[i] = fmt.Sprintf("%v %v", input.Type, input.Name)
		types[i] = input.Type.String()
	}
	for i, output := range outputs {
		outputNames[i] = output.Type.String()
		if len(output.Name) > 0 {
			outputNames[i] += fmt.Sprintf(" %v", output.Name)
		}
	}
	// calculate the signature and method id. Note only function has meaningful signature and id.
	// 计算签名和方法id。注意只有函数具有有意义的签名和 id。
	var (
		sig string
		id  []byte
	)
	if funType == Function {
		sig = fmt.Sprintf("%v(%v)", rawName, strings.Join(types, ","))
		id = crypto.Keccak256([]byte(sig))[:4]
	}
	identity := fmt.Sprintf("function %v", rawName)
	switch funType {
	case Fallback:
		identity = "fallback"
	case Receive:
		identity = "receive"
	case Constructor:
		identity = "constructor"
	}
	var str string
	// Extract meaningful state mutability of solidity method. If it's empty string or default value "nonpayable", never print it.
	// 提取 Solidity 方法有意义的状态可变性。如果它是空字符串或默认值“nonpayable”，则永远不要打印它。
	if mutability == "" || mutability == "nonpayable" {
		str = fmt.Sprintf("%v(%v) returns(%v)", identity, strings.Join(inputNames, ", "), strings.Join(outputNames, ", "))
	} else {
		str = fmt.Sprintf("%v(%v) %s returns(%v)", identity, strings.Join(inputNames, ", "), mutability, strings.Join(outputNames, ", "))
	}

	return Method{
		Name:            name,
		RawName:         rawName,
		Type:            funType,
		StateMutability: mutability,
		Constant:        isConst,
		Payable:         isPayable,
		Inputs:          inputs,
		Outputs:         outputs,
		str:             str,
		Sig:             sig,
		ID:              id,
	}
}

func (method Method) String() string {
	return method.str
}

// IsConstant returns the indicator whether the method is read-only.
// IsConstant 返回该方法是否只读的指示符。
func (method Method) IsConstant() bool {
	return method.StateMutability == "view" || method.StateMutability == "pure" || method.Constant
}

// IsPayable returns the indicator whether the method can process plain ether transfers.
// IsPayable 返回该方法是否可以处理普通以太传输的指示符。
func (method Method) IsPayable() bool {
	return method.StateMutability == "payable" || method.Payable
}


